<!DOCTYPE html>
<html>
<head>
    <title>Iteration Tracking Board</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows configuring of rows for the cardboard
     *
     *
     *      @example
     *      Ext.create('Ext.Container', {
     *          items: [{
     *              xtype: 'rowsettingsfield',
     *              value: {
     *                  show: true,
     *                  field: 'c_ClassofService'
     *              }
     *          }],
     *          renderTo: Ext.getBody().dom
     *      });
     *
     */
    Ext.define('Rally.apps.common.RowSettingsField', {
        alias: 'widget.rowsettingsfield',
        extend: 'Ext.form.FieldContainer',
        requires: [
            'Rally.ui.CheckboxField',
            'Rally.ui.combobox.ComboBox',
            'Rally.ui.plugin.FieldValidationUi',
            'Rally.data.ModelFactory',
            'Rally.data.wsapi.ModelBuilder'
        ],

        mixins: {
            field: 'Ext.form.field.Field'
        },

        layout: 'hbox',

        cls: 'row-settings',

        config: {
            /**
             * @cfg {Object}
             *
             * The row settings value for this field
             */
            value: undefined,

            /**
             * @cfg {Function}
             * A function which should return true if the specified field should
             * be included in the list of available swimlane fields
             * @param {Rally.data.wsapi.Field} field
             */
            isAllowedFieldFn: Ext.emptyFn,

            /**
             * @cfg {Object[]}
             *
             * Array of objects with name and value keys to be used by the row combobox
             * [{'name': 'Blocked', 'value': 'Blocked'},{'name': 'Owner', 'value': 'Owner'}]
             */
            explicitFields: [],

            /**
             * @cfg {String[]}
             * Array of models for which to list fields for
             */
            modelNames: ['userstory', 'defect']
        },

        initComponent: function() {
            this.callParent(arguments);

            this.mixins.field.initField.call(this);

            this.add([
                {
                    xtype: 'rallycheckboxfield',
                    name: 'showRows',
                    boxLabel: '',
                    margin: '0',
                    submitValue: false,
                    value: this.getValue().showRows,
                    listeners: {
                        change: function(checkbox, checked) {
                            this.down('rallycombobox').setDisabled(!checked);
                        },
                        scope: this
                    }
                },
                {
                    xtype: 'rallycombobox',
                    plugins: ['rallyfieldvalidationui'],
                    name: 'rowsField',
                    margin: '0 6px',
                    width: 130,
                    emptyText: 'Choose Field...',
                    displayField: 'name',
                    valueField: 'value',
                    disabled: this.getValue().showRows !== 'true',
                    editable: false,
                    submitValue: false,
                    storeType: 'Ext.data.Store',
                    storeConfig: {
                        remoteFilter: false,
                        fields: ['name', 'value'],
                        data: []
                    }
                }
            ]);

            this._loadModels();
        },

        _loadModels: function() {
            Rally.data.ModelFactory.getModels({
                types: this.getModelNames(),
                context: this.context,
                success: this._onModelsRetrieved,
                scope: this
            });
        },

        _onModelsRetrieved: function (models) {
            var fields = _.uniq(Ext.Array.merge(this.explicitFields, this._getRowableFields(_.values(models))), 'name');
            var combobox = this.down('rallycombobox');
            combobox.getStore().loadData(_.sortBy(fields, 'name'));
            combobox.setValue(this.getValue().rowsField);
            this.fireEvent('ready', this);
        },

        _getRowableFields: function (models) {
            var artifactModel = Rally.data.wsapi.ModelBuilder.buildCompositeArtifact(models, this.context),
                allFields = artifactModel.getFields(),
                rowableFields = _.filter(allFields, function (field) {
                    var attr = field.attributeDefinition;
                    return attr && !attr.Hidden && attr.Sortable &&
                        artifactModel.getModelsForField(field).length === models.length &&
                        this.isAllowedFieldFn(field);
                }, this);

            return _.map(rowableFields, function(field) {
                return {
                    name: field.displayName,
                    value: field.name
                };
            });
        },

        /**
         * When a form asks for the data this field represents,
         * give it the name of this field and the ref of the selected project (or an empty string).
         * Used when persisting the value of this field.
         * @return {Object}
         */
        getSubmitData: function() {
            var data = {},
                showField = this.down('rallycheckboxfield'),
                rowsField = this.down('rallycombobox'),
                showRows = showField.getValue() && !_.isEmpty(rowsField.getValue());
            data[showField.name] = showRows;
            if (showRows) {
                data[rowsField.name] = rowsField.getValue();
            }
            return data;
        },

        refreshWithNewModelType: function(type) {
            this.setModelNames([type]);
            this._loadModels();
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     *
     */
    Ext.define('Rally.apps.iterationtrackingboard.IterationTrackingTreeGrid', {
        extend: 'Rally.ui.grid.TreeGrid',
        alias: 'widget.rallyiterationtrackingtreegrid',

        requires: ['Rally.ui.renderer.RendererFactory'],

        config: {
            /**
             * @cfg {Array}
             * Array of configurations for summary e.g. {field: 'PlanEstimate', type: 'sum', units: 'pt'}
             */
            summaryColumns: [
                {
                    field: 'PlanEstimate',
                    type: 'sum',
                    units: 'pt'
                },
                {
                    field: 'TaskEstimateTotal',
                    type: 'sum',
                    units: 'hr'
                },
                {
                    field: 'TaskRemainingTotal',
                    type: 'sum',
                    units: 'hr'
                }
            ],

            noDataHelpLink: {
                url: "https://help.rallydev.com/tracking-iterations#filter",
                title: "Filter Help Page"
            }
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Abstract class to handle expanding / collapsing for banner widgets
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.BannerWidget', {
        extend: 'Ext.Component',
        alias: 'widget.bannerwidget',

        config: {
            expanded: true
        },

        cls: 'stat-panel',

        data: {},

        tpl: [
            '<div class="expanded-widget"></div>',
            '<div class="collapsed-widget"></div>'
        ],

        onRender: function() {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this.callParent(arguments);
        },

        expand: function() {
            this.removeCls('collapsed');
            this.setExpanded(true);
        },

        collapse: function() {
            this.addCls('collapsed');
            this.setExpanded(false);
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * gauge chart for stats banner
     * abstract class
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Gauge', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannergauge',

        requires: [
            'Rally.ui.chart.Chart',
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],

        config: {
            context: null,
            store: null
        },

        onDataChanged: Ext.emptyFn,
        getChartEl: Ext.emptyFn,
        _getChartConfig: Ext.emptyFn,

        _tzOffsetPromises: {},

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        expand: function() {
            this.callParent();
            if (this.chart) {
                this.chart.doLayout();
            } else {
                this._addChart(this._getChartConfig({}));
            }
        },

        onRender: function() {
            this.callParent(arguments);
            if (!this.getContext().getTimeboxScope().getRecord()) {
                this._addEmptyChart();
            }
        },

        _addEmptyChart: function() {
            this._cleanupChart();
            this._addChart({
                chartData: {
                    series: [{
                        data: [
                            {
                                name: '',
                                y: 100,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            });
        },

        _cleanupChart: function () {
            if (this.chart) {
                this.chart.destroy();
                delete this.chart;
            }
        },

        onDestroy: function () {
            this._cleanupChart();
            this.callParent(arguments);
        },

        onResize: function() {
            if (this.chart && !this.getEl().up('.stats-banner.collapsed')) {
                this.chart.updateLayout();
            }
            this.callParent(arguments);
        },

        refreshChart: function(chartConfig) {
            Ext.suspendLayouts();
            this._cleanupChart();
            if (this.rendered && this.expanded) {
                this._addChart(chartConfig);
            }
            Ext.resumeLayouts();
            this.fireEvent('ready', this);
        },

        _addChart: function(chartConfig) {
            var height = 62;
            this.chart = Ext.create('Rally.ui.chart.Chart', Ext.apply({
                loadMask: false,
                renderTo: this.getChartEl(),
                cls: 'gauge',
                chartConfig: {
                    chart: {
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        defaultSeriesType: 'pie',
                        height: height,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0
                    },
                    plotOptions: {
                        pie: {
                            borderWidth: 0,
                            center: ['50%', '50%'],
                            dataLabels: {
                                enabled: false
                            },
                            size: height - 4,
                            innerSize: height - 14,
                            enableMouseTracking: false, //turns off chart hover, but for tooltips you'll need this on
                            shadow: false
                        }
                    },
                    title: '',
                    tooltip: {
                        enabled: false
                    }
                }
            }, chartConfig));
        },

        getTimeboxData: function() {
            return this._getTZOffset().then({
                success: function (tzOffset) {
                    var timebox = this.getContext().getTimeboxScope().getRecord();
                    if(timebox) {
                        return Rally.util.Timebox.getCounts(
                            timebox.get('StartDate'),
                            timebox.get('EndDate'),
                            this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays,
                            tzOffset);
                    } else {
                        return {
                            remaining: 0,
                            workdays: 0
                        };
                    }
                },
                scope: this
            });
        },

        _getTZOffset: function() {
            var projectRef = Rally.util.Ref.getRelativeUri(this.getContext().getProject());
            if (!Ext.isDefined(this._tzOffsetPromises[projectRef])) {
                var deferred = this._tzOffsetPromises[projectRef] = Ext.create('Deft.Deferred');
                Rally.environment.getIoProvider().httpGet({
                    url: Rally.environment.getServer().getWsapiUrl() + '/iteration',
                    params: {
                        includeSchema: true,
                        pagesize:1,
                        fetch: false,
                        project: projectRef
                    },
                    success: function(results) {
                        deferred.resolve((results.Schema.properties.EndDate.format.tzOffset || 0) / 60);
                    },
                    requester: this,
                    scope: this
                });
            }
            return this._tzOffsetPromises[projectRef];
        },

        getAcceptanceData: function () {
            var scheduleStates = this.store.model.getField('ScheduleState').getAllowedStringValues();
            var acceptanceData = {
                accepted: 0,
                total: 0
            };
            var accepted = _.indexOf(scheduleStates, 'Accepted');
            _.each(this.store.getRange(), function (record) {
                var estimate = record.get('PlanEstimate') || 0;
                if (_.indexOf(scheduleStates, record.get('ScheduleState')) >= accepted) {
                    acceptanceData.accepted += estimate;
                }
                acceptanceData.total += estimate;
            }, this);
            return acceptanceData;
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows planned velocity for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.PlannedVelocity', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbannerplannedvelocity',
        require: ['Rally.util.Colors'],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Planned Velocity</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text percent-offset">',
            '{percentage}<div class="metric-percent">%</div>',
            '</div>',
            '<div class="metric-subtext">{estimate} of {plannedVelocity} {unit}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">Planned Velocity</div>',
            '<div class="stat-metric">{percentage}<span class="metric-percent">%</span></div>',
            '</div>'
        ],

        config: {
            data: {
                percentage: 0,
                estimate: 0,
                plannedVelocity: 0,
                unit: ''
            }
        },

        onDataChanged: function() {
            this._getRenderData().then({
                success: function(renderData){
                    this.update(renderData);
                    this.refreshChart(this._getChartConfig(renderData));
                },
                scope: this
            });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        _getTimeboxUnits: function() {
            return this.getContext().getTimeboxScope().getType() === 'iteration' ?
                this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName :
                this.getContext().getWorkspace().WorkspaceConfiguration.ReleaseEstimateUnitName;
        },

        _getRenderData: function() {
            var deferred = Ext.create('Deft.Deferred');
            var estimate = _.reduce(this.store.getRange(), function(accum, record) {
                return accum + record.get('PlanEstimate') || 0;
            }, 0);

            estimate = Math.round(estimate * 100) / 100;

            var timebox = this.getContext().getTimeboxScope();
            var timeboxUnits = this._getTimeboxUnits();
            timebox.getPlannedVelocity().then({
                success: function(plannedVelocity){
                    var percentage = plannedVelocity === 0 ? 0 : Math.round(estimate / plannedVelocity * 100);

                    var data = {
                        estimate: estimate,
                        percentage: percentage,
                        plannedVelocity: plannedVelocity,
                        unit: timeboxUnits
                    };
                    deferred.resolve(data);
                }
            });

            return deferred.promise;
        },

        _getChartConfig: function(renderData) {
            var percentage = renderData.percentage,
                percentagePlanned = percentage % 100 || 100,
                color = Rally.util.Colors.cyan_med,
                secondaryColor = Rally.util.Colors.grey1;

            if (percentage > 100) {
                color = Rally.util.Colors.blue;
                secondaryColor = Rally.util.Colors.cyan;
            } else if (percentage > 70) {
                color = Rally.util.Colors.cyan;
            } else if (percentage === 0) {
                color = Rally.util.Colors.grey1;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Planned Estimate Total',
                                y: percentagePlanned,
                                color: color
                            },
                            {
                                name: '',
                                y: 100 - percentagePlanned,
                                color: secondaryColor
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows days remaining for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.TimeboxEnd', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbannertimeboxend',
        requires: [
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">{type} End</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text">',
            '{remaining}',
            '</div>',
            '<div class="metric-subtext">days left of {workdays}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">{type} End</div>',
            '<div class="stat-metric">{remaining}<span class="stat-metric-secondary"> days</span></div>',
            '</div>'
        ],

        config: {
            data: {
                type: 'Iteration',
                remaining: 0,
                workdays: 0
            }
        },

        onDataChanged: function() {
            this.getTimeboxData().then({
                success: this._onDataAssembled,
                scope: this
            });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },


        _onDataAssembled: function (timeboxData) {
            var renderData = _.merge(
                {type: Ext.String.capitalize(this.getContext().getTimeboxScope().getType())},
                this.getAcceptanceData(),
                timeboxData
            );
            this.update(renderData);

            this.refreshChart(this._getChartConfig(renderData));
        },

        _getChartConfig: function (renderData) {
            var decimal = renderData.remaining / renderData.workdays,
                percentLeft = decimal < 1 ? Math.round(decimal * 100) : 0,
                color = Rally.util.Colors.cyan;

            if (renderData.total === 0) {
                color = Rally.util.Colors.grey1;
            } else if (percentLeft === 0) {
                color = renderData.accepted === renderData.total ? Rally.util.Colors.lime : Rally.util.Colors.blue;
            } else if (percentLeft <= 25) {
                color = Rally.util.Colors.blue;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Days Done',
                                y: 100 - percentLeft,
                                color: color
                            },
                            {
                                name: 'Days Left',
                                y: percentLeft,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows defects active for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Defects', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannerdefects',
        requires: [],

        config: {
            context: null,
            store: null,
            data: {
                activeCount: 0
            }
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Defects</div>',
            '<div class="stat-metric">',
            '<div class="metric-icon icon-defect"></div>{activeCount}',
            '<div class="stat-secondary">Active</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-defect"></span>',
            '<div class="stat-title">Defects</div>',
            '<div class="stat-metric">{activeCount}</div>',
            '</div>'
        ],

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        onDataChanged: function() {
            this.update(this._getRenderData());
            this.fireEvent('ready', this);
        },

        _getActiveDefectCount: function() {
            var activeDefects = 0;
            _.each(this.store.getRange(), function(record){
                var defectSummary = record.get('Summary') && record.get('Summary').Defects;
                if (defectSummary) {
                    _.each(defectSummary.State, function(count, state) {
                        if (state !== 'Closed') {
                            activeDefects += count;
                        }
                    }, this);
                } else if(record.self.typePath === 'defect' && record.get('State') !== 'Closed') {
                    activeDefects++;
                }
            }, this);
            return activeDefects;
        },

        _getRenderData: function() {
            return {activeCount: this._getActiveDefectCount()};
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Accepted', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbanneraccepted',
        requires: ['Rally.util.Colors'],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Accepted</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text percent-offset">',
            '{percentage}<div class="metric-percent">%</div>',
            '</div>',
            '<div class="metric-subtext">{accepted} of {total} {unit}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">Accepted</div>',
            '<div class="stat-metric">{percentage}<span class="metric-percent">%</span></div>',
            '</div>'
        ],

        config: {
            data: {
                percentage: 0,
                accepted: 0,
                total: 0,
                unit: ''
            }
        },

        onDataChanged: function () {
            this.getTimeboxData().then({
                success: this._onDataAssembled,
                scope: this
            });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        _getTimeboxUnits: function() {
            return this.getContext().getTimeboxScope().getType() === 'iteration' ?
                    this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName :
                    this.getContext().getWorkspace().WorkspaceConfiguration.ReleaseEstimateUnitName;
        },

        _getRenderData: function(timeboxData) {
            var data = _.merge(
                {unit: this._getTimeboxUnits()},
                this.getAcceptanceData(),
                timeboxData
            );

            data.accepted = Ext.util.Format.round(data.accepted, 2);
            data.total = Ext.util.Format.round(data.total, 2);
            data.percentage = Math.round((data.accepted / data.total) * 100) || 0;

            return data;
        },

        _onDataAssembled: function (timeboxData) {
            var renderData = this._getRenderData(timeboxData);
            this.update(renderData);

            this.refreshChart(this._getChartConfig(renderData));
        },

        _getChartConfig: function(renderData) {
            var color = Rally.util.Colors.cyan,
                daysRemaining = renderData.remaining / renderData.workdays,
                percentage = renderData.percentage;

            if (percentage === 100) {
                color = Rally.util.Colors.lime;
            } else if (daysRemaining === 0) {
                color = Rally.util.Colors.blue;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Accepted',
                                y: percentage,
                                color: color
                            },
                            {
                                name: '',
                                y: 100 - percentage,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows completed tasks for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Tasks', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannertasks',
        requires: [],

        config: {
            context: null,
            store: null,
            data: {
                count: 0
            }
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Tasks</div>',
            '<div class="stat-metric">',
            '<span class="metric-icon icon-task"></span>{count}',
            '<div class="stat-secondary">Active</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-task"></span>',
            '<div class="stat-title">Tasks</div>',
            '<div class="stat-metric">{count}</div>',
            '</div>'
        ],

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        onDataChanged: function() {
            this.update(this._getRenderData());
            this.fireEvent('ready', this);
        },

        _getRenderData: function() {
            return {count: this._getTaskCount()};
        },

        _getTaskCount: function() {
            var taskCount = 0;
            _.each(this.store.getRange(), function(record){
                var taskSummary = record.get('Summary') && record.get('Summary').Tasks;
                if (taskSummary) {
                    _.each(taskSummary['state+blocked'], function(count, state) {
                        if (!Ext.String.startsWith(state, 'Completed')) {
                            taskCount += count;
                        }
                    }, this);
                }
            }, this);
            return taskCount;
        }
    });
})();
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        _configureYAxis: function(ticks, axis) {

            var intervalY = (this.chartComponentConfig.chartConfig.yAxis[axis].max - 0) / (ticks - 1);
            var ticksY = [];
            for (var i = 0; i < ticks; i++) {
                ticksY.push(i * intervalY);
            }
            this.chartComponentConfig.chartConfig.yAxis[axis].tickPositions = ticksY;
        },

        _configureYAxisIntervals: function () {
            var ticks = 5; // not much chart space, limit to 5
            this._configureYAxis(ticks, 0);
            if(this.chartType === "burndown") { // cumulative flow only has y axis 0
                this._configureYAxis(ticks, 1);
            }
        },

        _getElementValue: function (element) {
            if (element.textContent !== undefined) {
                return element.textContent;
            }
            return element.text;
        },
        
        _getStringValues: function (elements) {
            var i;
            var strings = [];
            for (i = 0; i < elements.length; i++) {
                strings.push(this._getElementValue(elements[i]));
            }
            return strings;
        },

        _getNumberValues: function (elements) {
            var i;
            var numbers = [];
            for (i = 0; i < elements.length; i++) {
                if(this._getElementValue(elements[i])) {
                    numbers.push(this._getElementValue(elements[i]).split(' ')[0] * 1);
                } else {
                    numbers.push(0);
                }

            }
            return numbers;
        },

        _computeMaxYAxisValue: function(series) {
            var i, j, max = 0.0;
            // sum each day's values and find the largest sum
            for(i=0; i < series[0].data.length; i++) {
                var val = 0.0;
                for(j=0; j < series.length; j++) {
                    // if is for insurance, _should_ always be true
                    if(series[j].data.length === series[0].data.length) {
                        val += series[j].data[i];
                    }
                }
                if(val > max) {
                    max = val;
                }
            }
            max = Math.ceil(max / 4) * 4;  // round up to multiple of 4 so we will create 5 integral tick marks

            return (max === 0) ? 4 : max;
        },

        _createChartDatafromXML: function (xml) {
            var parseXml;

            if (typeof window.DOMParser !== "undefined") {
                parseXml = function (xmlStr) {
                    return ( new window.DOMParser() ).parseFromString(xmlStr, "text/xml");
                };
            } else if (typeof window.ActiveXObject !== "undefined" &&
                new window.ActiveXObject("Microsoft.XMLDOM")) {
                parseXml = function (xmlStr) {
                    var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = "false";
                    xmlDoc.loadXML(xmlStr);
                    return xmlDoc;
                };
            } else {
                throw new Error("No XML parser found");
            }

            return parseXml(xml);
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart", {
            requires: [
                "Rally.ui.chart.Chart"
            ],

            chartComponentConfig: {
               xtype: "rallychart",
               suppressClientMetrics: true /* keeps rallychart::lookback query time from displaying in client metrics */
            }
        });
}());

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart", {
        alias: "widget.statsbannerburndownchart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: [
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin",
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart"
        ],

        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Burndown',
        minimalMode: false,
        onChartDataLoaded: Ext.emptyFn,

        initComponent: function() {
            this.callParent(arguments);

            Ext.Ajax.request({
                url: '/slm/charts/itsc.sp',
                params: {
                    iterationOid: this.context.getTimeboxScope().getRecord().getId(),
                    cpoid: this.context.getProject().ObjectID
                },
                method: 'GET',
                withCredentials: true,
                success: function(response, request) {
                    this._loadData(response.responseText);
                },
                requester: this,
                scope: this
            });
        },

        _loadData: function(chartData) {
            var xmlDoc = this._createChartDatafromXML(chartData);
            this._createBurndownChartDatafromXML(xmlDoc);
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;

            return Ext.Object.merge({
                xtype: 'rallychart',
                chartColors: ["#005eb8", "#666666", "#8dc63f" ],
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartConfig: {
                    chart: {
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        zoomType: 'xy',
                        alignTicks: false,
                        animation: true,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            shadow: false,
                            borderWidth: 0,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            },
                            events: {
                                click: clickChartHandler
                            }
                        },
                        column: {
                            point: {
                               events: {
                                   click: clickChartHandler
                               }
                           }
                        }
                    },
                    legend: { enabled: true },
                    title: { text: null },
                    xAxis: {
                        tickmarkPlacement: 'on',
                        tickInterval: 1
                    },
                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { style: { color: "#005eb8" } }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { style: { color: "#8dc63f" } }
                        }
                    ]
                },
                chartData: {
                    categories: [],
                    series: [
                        {
                            name: "To Do",
                            type: "column",
                            data: [],
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Ideal",
                            type: "line",
                            dashStyle: "Solid",
                            data: [],
                            marker : {
                               enabled : true,
                               radius : 3
                            },
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Accepted",
                            type: "column",
                            data: [],
                            yAxis: 1,
                            tooltip: { enabled: false }
                        }
                    ]
               }
           }, overrides || {});
        },

        _createMinimalConfig: function(){
            var config = this._createChartConfig();
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;
            delete config.chartData.series[1].marker;

            config = Ext.Object.merge(config, {
                chartConfig: {
                    chart: {
                        zoomType: ''
                    },
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },

                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { enabled: false }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { enabled: false }
                        }
                    ],
                    title: { text: null }
                }
            });
            return config;
        },

        _createBurndownChartDatafromXML: function (xmlDoc) {

            this.chartComponentConfig = this.minimalMode ? this._createMinimalConfig() : this._createChartConfig();

            var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];
            var xmlChartValueText = xmlDoc.getElementsByTagName("chart_value_text")[0];
            var draw = xmlDoc.getElementsByTagName("draw")[0];
            var axis_value = xmlDoc.getElementsByTagName("axis_value")[1];

            var rows = xmlChartData.getElementsByTagName("row");

            // this makes no sense...The thing labeled Accepted in the <chart_data> element, isn't.
            // The thing that is Accepted, is buried in the <chart_value_text> element

            this.chartComponentConfig.chartData.categories = this._getStringValues(rows[0].getElementsByTagName("string")); // categories
            this.chartComponentConfig.chartData.series[0].data = this._getNumberValues(rows[1].getElementsByTagName("number")); //todo;
            this.chartComponentConfig.chartData.series[1].data = this._getNumberValues(rows[3].getElementsByTagName("number")); //ideal;
            this.chartComponentConfig.chartData.series[2].data = this._getNumberValues(xmlChartValueText.getElementsByTagName("row")[2].getElementsByTagName("number")); //accepted;
            this.chartComponentConfig.chartConfig.yAxis[0].max = axis_value.getAttribute("max") * 1;

            var texts = draw.getElementsByTagName("text");
            // find the last <text element with orientation="vertical_down" attribute, that's the max y-axis 2 setting
            for (i = 0; i < texts.length; i++) {
                if (texts[i].getAttribute("orientation") === "vertical_down") {
                    this.chartComponentConfig.chartConfig.yAxis[1].max = (this._getElementValue(texts[i]) * 1);
                }
            }
            this._configureYAxisIntervals();

            this.chartComponentConfig.chartConfig.xAxis.tickInterval = Math.floor(this.chartComponentConfig.chartData.series[0].data.length / 4);

            this.add(this.chartComponentConfig);
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        }
    });
})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart", {
        alias: "widget.statsbannercumulativeflowchart",
        extend: "Ext.Container",
        requires: [ 'Rally.ui.chart.Chart' ],
        mixins: [
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin",
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart"
        ],
        cls: 'rally-iteration-progress-cumulative-flow-chart',
        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Cumulative Flow',
        minimalMode: false,
        initComponent: function() {
            this.callParent(arguments);

            Ext.Ajax.request({
                url: '/slm/charts/icfc.sp',
                params: {
                    iterationOid: this.context.getTimeboxScope().getRecord().getId(),
                    cpoid: this.context.getProject().ObjectID,
                    bigChart: true
                },
                method: 'GET',
                withCredentials: true,
                success: function(response, request) {
                    this._loadData(response.responseText);
                },
                requester: this,
                scope: this
            });
        },

        _loadData: function(chartData) {
            var xmlDoc = this._createChartDatafromXML(chartData);
            this._createCumulativeFlowChartDatafromXML(xmlDoc);
        },

        _createMinimalConfig: function(){
            var config = this._createChartConfig();
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;

            return Ext.Object.merge(config, {
                chartConfig: {
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },
                    yAxis: [{
                        title: {
                            text: null
                        },
                        min: 0,
                        labels: { enabled: false }
                    }],
                    title: { text: null }
                }
            });
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;

            return Ext.Object.merge({
                xtype: 'rallychart',
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartColors: [  // RGB values obtained from here: http://ux-blog.rallydev.com/?cat=23
                                "#C0C0C0",  // $grey4
                                "#FF8200",  // $orange
                                "#F6A900",  // $gold
                                "#FAD200",  // $yellow
                                "#CADDA3",  // $lime
                                "#1E7C00"
                            ],
                chartConfig: {
                    chart: {
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        alignTicks: false,
                        animation: true,
                        type: "area",
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        area: {
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            stacking: 'normal'
                        }
                    },
                    legend: {
                        enabled: true
                    },
                    title: { text: null },
                    xAxis: {
                        tickmarkPlacement: 'on',
                        tickInterval: 1
                    },
                    yAxis: [{
                        title: { text: null },
                        min: 0,
                        labels: {
                            style: { color: "#005eb8" }
                        }
                    }]
                },
                chartData: {
                   categories: [],
                   series: []
                }
           }, overrides || {});
        },

        _createCumulativeFlowChartDatafromXML: function (xmlDoc) {

            this.chartComponentConfig = this.minimalMode ? this._createMinimalConfig() : this._createChartConfig();

            var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];

            var rows = xmlChartData.getElementsByTagName("row");
            var i, j;
            this.chartComponentConfig.chartData.categories = this._getStringValues(rows[0].getElementsByTagName("string")); // categories
            for(j=rows.length-1, i = 0 ; j > 0; j--,i++) {
                this.chartComponentConfig.chartData.series[i] = {};
                this.chartComponentConfig.chartData.series[i].data = this._getNumberValues(rows[j].getElementsByTagName("number"));
                this.chartComponentConfig.chartData.series[i].name = this._getStringValues(rows[j].getElementsByTagName("string"))[0];
            }

            // the 'max' y axis value in the xml isn't correct, so we'll calculate it ourselves...
            this.chartComponentConfig.chartConfig.yAxis[0].max = this._computeMaxYAxisValue(this.chartComponentConfig.chartData.series);

            this._configureYAxisIntervals();


            // Use number of ScheduleState values to show as a surrogate for with of the legend text.
            if(this.chartComponentConfig.chartData.series.length === 6) {
                this.chartComponentConfig.chartConfig.legend.itemStyle = { fontSize: '8px'};
            } else if(this.chartComponentConfig.chartData.series.length === 5) {
                this.chartComponentConfig.chartConfig.legend.itemStyle = { fontSize: '10px'};
            } // else it will default to 12px

            this.chartComponentConfig.chartConfig.xAxis.tickInterval = Math.floor(this.chartComponentConfig.chartData.series[0].data.length / 4);

            this.add(this.chartComponentConfig);
        },


        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        }
    });

})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart", {
        alias: "widget.statsbannerpiechart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: {
            recordable: 'Rally.clientmetrics.ClientMetricsRecordable'
        },

        currentScope: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Pie',
        config: {
            context: null
        },

        initComponent: function() {
            this.callParent(arguments);

            if (this._storyStates === undefined) {
                Rally.data.ModelFactory.getModels({
                    types: ['UserStory', 'Defect', 'DefectSuite', 'TestSet'],
                    context: this.getContext(),
                    scope: this,
                    requester: this,
                    success: this._createStateMap
                });
            } else {
                this._loadArtifacts();
            }
        },

        _createStateMap: function(models) {
            var stateMap = ['Defined', 'In-Progress', 'Completed'],
                stateMapIndex = 0,
                storyStates = {};

            _.each(models.UserStory.getField('ScheduleState').getAllowedStringValues(), function(state) {
                if (state === stateMap[stateMapIndex + 1]) {
                    stateMapIndex++;
                }
                storyStates[state] = stateMap[stateMapIndex];
            });

            this._storyStates = storyStates;
            this._loadArtifacts();
        },

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];

            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],
                fetch: ['Defects', 'PlanEstimate', 'Requirement', 'FormattedID', 'Name', 'Blocked', 'BlockedReason', 'ScheduleState', 'State', 'Tasks', 'TestCases'],
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                sorters: [
                    {property: 'ScheduleState'}
                ],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this,
                autoLoad: true,
                listeners: {
                    load: this._loadChildCollections,
                    scope: this
                }
            });
        },

        _loadChildCollections: function() {
            var records = this.store.getRange();
            var promises = [];
            _.each(records, function(record) {
                if (record.get('Defects') && record.get('Defects').Count) {
                    promises.push(record.getCollection('Defects', {
                        fetch: ['FormattedID', 'Name', 'ScheduleState', 'Blocked', 'BlockedReason', 'Requirement', 'State']
                    }).load({
                        requester: this,
                        callback: function(defects) {
                            record.get('Defects').Results = defects;
                        }
                    }));
                }
                if (record.get('Tasks') && record.get('Tasks').Count) {
                    promises.push(record.getCollection('Tasks', {
                        fetch: ['FormattedID', 'Name', 'Blocked', 'BlockedReason', 'WorkProduct', 'State']
                    }).load(
                        {
                            requester: this,
                            callback: function(tasks) {
                                record.get('Tasks').Results = tasks;
                            }
                        }
                    ));
                }
                if (record.get('TestCases') && record.get('TestCases').Count){
                    promises.push(record.getCollection('TestCases', {
                        fetch: ['FormattedID', 'Name', 'Type', 'WorkProduct']
                    }).load({
                        requester: this,
                        callback: function(testCases){
                            record.get('TestCases').Results = testCases;
                            }
                        }
                    ));
                }
            });

            if (promises.length > 0) {
                Deft.Promise.all(promises).then({
                    success: this._onAllDataLoaded,
                    scope: this
                });
            } else {
                this._onAllDataLoaded();
            }
        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var defects = record.get('Defects');
                var defectCount = (defects && defects.Count) || 0;
                var tasks = record.get('Tasks');
                var taskCount = (tasks && tasks.Count) || 0;
                var testCases =  record.get('TestCases');
                var testCaseCount = (testCases && testCases.Count) || 0;
                var relatedCount = taskCount + defectCount + testCaseCount;
                var planEstimate = record.get('PlanEstimate') || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No tasks or defects.';

                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (defects && defects.Results) {
                        _.each(defects.Results, function(defect) {
                            this._addPointForChildItem(defect, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (tasks && tasks.Results) {
                        _.each(tasks.Results, function(task) {
                            this._addPointForChildItem(task, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (testCases && testCases.Results) {
                        _.each(testCases.Results, function(testCase) {
                            this._addPointForChildItem(testCase, record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                        }, this);
                    }
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            var pieHeight = this.height * 0.9;

            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type: 'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: pieHeight,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type: 'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: pieHeight,
                            innerSize: 0.8 * pieHeight,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 3,
                        spacingBottom: 0,
                        spacingLeft: 3,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    subtitle: {
                        useHTML: true,
                        text: '<table align="center" class="pie-chart-legend"><tr><td><span class="legend-swatch defined-sample-swatch"></span><span>Defined</td>' +
                              '<td><span class="legend-swatch in-progress-sample-swatch"></span>In-Progress</td>' +
                              '<td><span class="legend-swatch completed-sample-swatch"></span>Completed</td>' +
                              '<td><span class="legend-swatch blocked-sample-swatch"></span>Blocked</td></tr></table>',
                        verticalAlign: 'bottom',
                        floating: true,
                        x: -10,
                        y: -20
                    },
                    tooltip: {
                        formatter: this._formatTooltip,
                        useHTML: true
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            cursor: 'pointer',
                            shadow: false,
                            center: ['50%', '45%'],
                            point: {
                                events: {
                                    click: function(event) {
                                        if (this.ref) {
                                            Rally.nav.Manager.showDetail(this.ref);
                                        }
                                    }
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = record.get('Blocked');
            var color = this._colorFromStatus(this._storyStates[record.get('ScheduleState')], blocked);
            var pointSize = record.get('PlanEstimate') || 1;

            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: record.get('ScheduleState'),
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _colorFromStatus: function(state, blocked) { //refactor into css and classes, should get cleaner
            var progressColors = {
                'Defined': '#C0C0C0', // light gray
                'In-Progress': '#00A9E0', // cyan
                'Completed': '#8DC63F', // lime
                'Blocked': '#EE1C25' // red
            };
            var color =  progressColors[state];
            if (blocked) {
                color = progressColors.Blocked;
            }
            return color;
        },

        _addPointForChildItem: function(record, parentFormattedID, pointSize, parentState, isParentBlocked) {
            var blocked = record.get('Blocked');
            var state = record.get('ScheduleState') || record.get('State') || record.get('Type');
            var color = this._colorFromStatus(this._storyStates[parentState || state], blocked || isParentBlocked);

            this._childChartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: state,
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: false,
                relatedCount: 0,
                ref: record.get('_ref'),
                parentFormattedID: parentFormattedID
            });
        },

        _formatTooltip: function() {
            var relatedMessage = '';
            var blockedMessage = '';
            var artifactName = this.point.rallyName ? '<b>' + this.point.name + '</b>: ' + this.point.rallyName + '<br/>' : this.point.name;

            if (this.point.blocked) {
                blockedMessage = '<br/><b>Blocked</b>';
                if (this.point.blockedReason) {
                    blockedMessage += ': ' + this.point.blockedReason;
                }
            }

            if (this.point.series && this.point.series.name === 'Parents') {
                relatedMessage = (this.point.relatedCount) ? '<br/>Related Items: ' + this.point.relatedCount : '';
            }

            return '<div style="min-width:200px;white-space:normal">' + artifactName + this.point.status + relatedMessage + blockedMessage + '</div>';
        }
    });
})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.MinimalPieChart", {
        alias: "widget.statsbannerminimalpiechart",
        extend: "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart",

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];
            this._createDataPointsFromSummary();
        },

        _createDataPointsFromSummary: function() {
            _.each(this.store.getRange(), function(record){
                var summary = record.get('Summary');
                var totalChildItems = 0;
                var planEstimate = record.get('PlanEstimate') || 1;
                var nullPointString = 'No tasks or defects.';
                var testCases = record.get('TestCases');
                var keys, state, scheduleState, blocked, count;

                totalChildItems += summary.Defects ? summary.Defects.Count : 0;
                totalChildItems += summary.Tasks ? summary.Tasks.Count : 0;
                totalChildItems += testCases ? testCases.Count : 0;

                var pointSizeForChildren = (planEstimate / totalChildItems) || 1;

                this._addPointForTopLevelItem(record, totalChildItems);

                if (totalChildItems === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                }
                if (summary.Tasks && summary.Tasks.Count){
                    keys = _.keys(summary.Tasks['state+blocked']);
                    _.each(keys, function(key) {
                        state = key.split('+');
                        scheduleState =  state[0];
                        blocked = state[1] === 'true';
                        count = summary.Tasks['state+blocked'][key];
                        _.each(_.range(0, count), function(point) {
                            this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, scheduleState, blocked);
                        }, this);
                    }, this);
                }
                if (summary.Defects && summary.Defects.Count){
                    keys = _.keys(summary.Defects['schedulestate+blocked']);
                    _.each(keys, function(key) {
                        state = key.split('+');
                        scheduleState =  state[0];
                        blocked = state[1] === 'true';
                        count = summary.Defects['schedulestate+blocked'][key];
                        _.each(_.range(0, count), function(point) {
                            this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, scheduleState, blocked);
                        }, this);
                    }, this);
                }
                if (testCases && testCases.Count){
                    _.each(_.range(0,testCases.Count), function(point){
                        this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                    }, this);
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var defects = record.get('Defects');
                var defectCount = (defects && defects.Count) || 0;
                var tasks = record.get('Tasks');
                var taskCount = (tasks && tasks.Count) || 0;
                var testCases =  record.get('TestCases');
                var testCaseCount = (testCases && testCases.Count) || 0;
                var relatedCount = taskCount + defectCount + testCaseCount;
                var planEstimate = record.get('PlanEstimate') || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No tasks or defects.';

                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (defects && defects.Results) {
                        _.each(defects.Results, function(defect) {
                            this._addPointForChildItem(defect, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (tasks && tasks.Results) {
                        _.each(tasks.Results, function(task) {
                            this._addPointForChildItem(task, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (testCases && testCases.Results) {
                        _.each(testCases.Results, function(testCase) {
                            this._addPointForChildItem(testCase, record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                        }, this);
                    }
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

         _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type:'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: height,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type:'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: height,
                            innerSize: 0.8 * height,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            shadow: false,
                            center: ['50%', '50%'],
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = record.get('Blocked');
            var color = this._colorFromStatus(this._storyStates[record.get('ScheduleState')], blocked);
            var pointSize = record.get('PlanEstimate') || 1;

            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: record.get('ScheduleState'),
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _addPointForChildItem: function(parentFormattedID, pointSize, state, blocked) {
            var color = this._colorFromStatus(this._storyStates[state], blocked);

            this._childChartData.push({
                y: pointSize,
                color: color,
                status: state,
                blocked: blocked,
                hasChildren: false,
                relatedCount: 0,
                parentFormattedID: parentFormattedID
            });
        }
      
    });
})();

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialogChartToggle', {
        requires:['Rally.ui.Button'],
        extend:'Ext.Container',
        alias:'widget.iterationprogressdialogcharttoggle',

        componentCls: 'iteration-progress-toggle-button-group',
        layout: 'hbox',
        border: 1,
        width: 106,
        activeButtonCls: 'rly-active',

        defaultType: 'rallybutton',

        config: {
            startingIndex: 0
        },

        items: [{
            cls: 'toggle rly-left pie-chart',
            iconCls: 'icon-pie',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            style: {
                fontSize: '15px'
            },
            toolTipConfig: {
                html: 'Pie',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked pie chart'
        },
        {
            cls: 'toggle center burndown',
            iconCls: 'icon-bars',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            toolTipConfig: {
                html: 'Burndown',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked burndown'
        },
        {
            cls: 'toggle rly-right cumulativeflow',
            iconCls: 'icon-graph',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            toolTipConfig: {
                html: 'Cumulative Flow',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked CFD'
        }],

        initComponent: function(config) {
            this.initConfig(config);
            this.callParent(arguments);

            this.addEvents([
                /**
                 * @event toggle
                 * Fires when the toggle value is changed.
                 * @param {String} toggleState 'burndown' or 'cumulativeflow' or 'pie'.
                 */
                'toggle'
            ]);

            this.items.each(function(item) {
                item.on('click', this._onButtonClick, this);
            }, this);

            this.setCurrentItem(this.startingIndex);
        },

        _onButtonClick: function(btn) {
            var btnIndex = this.items.indexOf(btn);
            if (btnIndex !== this._activeIndex) {
                this._setActive(btn);
                this.fireEvent('toggle', this, btnIndex);
            }
        },

        _setActive: function(btn) {
            this.items.each(function(item, btnIndex) {
                if (item === btn) {
                    if (!item.hasCls(this.activeButtonCls.split(' ')[0])) {
                        item.addCls(this.activeButtonCls);
                        this._activeIndex = btnIndex;
                    }
                } else {
                    item.removeCls(this.activeButtonCls);
                }
            }, this);
        },

        setCurrentItem: function(itemIndex) {
            this._setActive(this.items.get(itemIndex));
        }
    });
})();


                (function(){

    var Ext = window.Ext4 || window.Ext;

    /**
    * shows burndown for timebox
    */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog', {
        extend: 'Rally.ui.dialog.Dialog',
        alias:'widget.statsbanneriterationprogressdialog',
        requires: [
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialogChartToggle',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart',
            'Rally.ui.carousel.Carousel'
        ],
        config: {
            startingIndex: 0,
            autoShow: true,
            draggable: true,
            disableScroll: true,
            width: 820,
            height: 650,
            closable: true,
            constrain: true,
            store: null,
            context: null
        },
        layout: {
            type: 'vbox',
            align: 'center'
        },
        cls: 'iteration-progress-dialog',

        constructor: function (config){
            this.initConfig(config || {});
            this.callParent(arguments);
        },

        initComponent: function(){
            var chartWidth = 704;
            var chartHeight = 570;

            this.callParent(arguments);
            this.toggle = this.add({
                xtype: 'iterationprogressdialogcharttoggle',
                startingIndex: this.startingIndex,
                listeners: {
                    toggle: this._toggleButtonClick,
                    scope: this
                }
            });
            this.carousel = this.add({
                xtype: 'rallycarousel',
                showDots: false,
                enableAnimations: false,
                carouselItems: [
                    {
                        xtype: 'statsbannerpiechart',
                        width: chartWidth,
                        height: chartHeight,
                        context: this.context
                    },
                    {
                        xtype: 'statsbannerburndownchart',
                        width: chartWidth,
                        height: chartHeight,
                        context: this.context,
                        store: this.store
                    },
                    {
                        xtype: 'statsbannercumulativeflowchart',
                        width: chartWidth,
                        height: chartHeight,
                        context: this.context,
                        store: this.store
                    }
                ],
                startingIndex: this.startingIndex,
                listeners: {
                    carouselmove: {
                        fn: this._onCarouselMove,
                        scope: this
                    },
                    afterlayout: {
                        fn: this._afterLayout,
                        single: true,
                        scope: this
                    }
                }
            });
        },

        _toggleButtonClick: function(toggleBtnContainer, buttonIndex){
            this._setChart(buttonIndex);
        },

        _afterLayout: function(){
            Ext.defer(this._setChart, 10, this, [this.startingIndex]);
        },

        _setChart: function(chartIndex) {
            this.carousel.setCurrentItem(chartIndex);
            this.toggle.setCurrentItem(chartIndex);
            // need to bypass the setTitle method as it causes a relayout of the page messing up the carousel
            this.header.titleCmp.textEl.update(this.carousel.getCurrentItem().displayTitle);
        },

        _onCarouselMove: function(carousel){
            this._setChart(carousel.getCurrentItemIndex());
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows burndown for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgress', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbanneriterationprogress',
        requires: [
            'Rally.ui.carousel.Carousel',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.MinimalPieChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart',
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog',
            'Ext.state.Manager'
        ],

        config: {
            context: null,
            store: null
        },

        currentChartDisplayed: 1,

        stateId: 'stats-banner-iteration-progress',
        stateful: true,

        clientMetrics: {
            method: '_onChartClick',
            description: 'opened IterationProgressDialog'
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title"></div>',
            '<div class="stat-metric">',
            '<div class="stat-carousel"></div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-pie"></span>',
            '<div class="stat-title"></div>',
            '</div>'
        ],

        initComponent: function () {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
            var boundClickHandler = Ext.bind(this._onChartClick, this);

            this.stateId = this.context.getScopedStateId(this.stateId);

            this.carouselItems = [
                {
                    xtype: 'statsbannerminimalpiechart',
                    width: 150,
                    height: 60,
                    minimalMode: true,
                    clickHandler: boundClickHandler,
                    context: this.context,
                    store: this.store
                },
                {
                    xtype: 'statsbannerburndownchart',
                    width: 150,
                    height: 63,
                    minimalMode: true,
                    clickHandler: boundClickHandler,
                    context: this.context,
                    store: this.store
                },
                {
                    xtype: 'statsbannercumulativeflowchart',
                    width: 150,
                    height: 63,
                    minimalMode: true,
                    clickHandler: boundClickHandler,
                    context: this.context,
                    store: this.store
                }
            ];

            _.each(this.carouselItems, function(carouselItem) {
                carouselItem.listeners = {
                    ready: this._onChartReady,
                    scope: this
                };
            }, this);

            this._pendingChartReadies = this.carouselItems.length;

            if (!this.expanded) {
                this.fireEvent('ready', this);
            } else {
                this.onDataChanged();
            }
        },

        expand: function() {
            this.callParent();
            // Carousel was updated while hidden so it needs to die
            // and we create a new one since it can't lay itself out
            if (!this.carousel || this.carousel.getWidth() === 0) {
                this.onDataChanged();
            }
        },

        _onChartReady: function() {
            this._pendingChartReadies -= 1;
            if (this._pendingChartReadies === 0) {
                this.fireEvent('ready', this);
            }
        },

        _onChartClick: function() {
            var currentIndex = this.carousel.getCurrentItemIndex();
            Ext.create('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog', {
                startingIndex: currentIndex,
                store: this.store,
                context: this.context
            });
        },

        _cleanupCarousel: function () {
            if (this.carousel) {
                this.carousel.destroy();
                delete this.carousel;
            }
        },

        onDestroy: function () {
            this._cleanupCarousel();
            this.callParent(arguments);
        },

        onRender: function() {
            this.callParent(arguments);
            if (!this.getContext().getTimeboxScope().getRecord()) {
                this._addPlaceholder();
            }
        },

        applyState: function (state) {
            if (state){
                if (state.currentChartDisplayed > this.carouselItems.length -1 || state.currentChartDisplayed < 0) {
                    this.currentChartDisplayed = 1;
                } else {
                    this.currentChartDisplayed = state.currentChartDisplayed;
                }
            }
        },

        getState: function(){
            return {
                currentChartDisplayed: this.currentChartDisplayed
            };
        },

        onDataChanged: function() {
            this._cleanupCarousel();

            var addCarousel = _.bind(function() {
                if (this.getContext().getTimeboxScope().getRecord()) {
                    this.update();

                    this.createCarousel();
                } else {
                    this._addPlaceholder();
                }
            }, this);
            if (this.expanded) {
                if (this.rendered) {
                    addCarousel();
                } else {
                    this.on('afterrender', addCarousel);
                }
            }
        },

        createCarousel: function() {
            this.carousel = Ext.create('Rally.ui.carousel.Carousel', {
                showHeader: false,
                showDots: true,
                smallDots: true,
                renderTo: this.getEl().down('.stat-carousel'),
                height: 75,
                layout: {
                    type: 'vbox',
                    align: 'center'
                },
                listeners: {
                    currentitemset: this._updateTitle,
                    carouselmove: this._updateTitle,
                    scope: this
                },
                carouselItems: this.carouselItems
            });

            if (!Ext.isIE8m){
                // if such next line runs IE8 or < goes boom! WOW!
                this.carousel.setCurrentItem(this.currentChartDisplayed);
            }

            this.carousel.on('carouselmove', this._chartShownChanged, this);
        },

        _updateTitle: function(carousel){
            _.each(this.getEl().query('.stat-title'), function(el){
                Ext.fly(el).update(carousel.getCurrentItem().displayTitle);
            }, this);
        },

        _chartShownChanged: function(){
            var chartShown = _.findIndex(this.carouselItems, {xtype: this.carousel.getCurrentItem().xtype});
            this.currentChartDisplayed = chartShown || 0;
            this.saveState();
        },

        _addPlaceholder: function() {
            this.update();

            if (this.expanded) {
                this.carousel = Ext.create('Ext.Container', {
                    renderTo: this.getEl().down('.stat-carousel'),
                    html: 'no iteration data'
                });
            }
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows collapse/expand toggle for stats banner
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.CollapseExpand', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannercollapseexpand',
        requires: [],
        mixins: [
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="toggle-icon icon-collapse-row"></div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="toggle-icon icon-expand-row"></div>',
            '</div>'
        ],

        componentCls: 'collapse-expand',

        bubbleEvents: ['collapse', 'expand'],

        afterRender: function() {
            this.callParent(arguments);
            this.parentComponent.getEl().on('click', this._onCollapseExpandClick, this);
            this.fireEvent('ready', this);
        },

        _onCollapseExpandClick: function (event, target) {
            if (this.expanded) {
                if (target.getAttribute('class').indexOf('toggle-icon') > -1 || Ext.get(target).down('div .toggle-icon')) {
                    this.fireEvent('collapse', this);
                }
            } else {
                this.fireEvent('expand', this);
            }
        },

        expand: function() {
            this.recordAction({
                description: 'Expand statsbanner'
            });
            this.callParent(arguments);
            this.doComponentLayout();
        },

        collapse: function() {
            this.recordAction({
                description: 'Collapse statsbanner'
            });
            this.callParent(arguments);
            this.doComponentLayout();
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows user to see stats for a timebox in a horizontal bar format
     */
    Ext.define('Rally.apps.iterationtrackingboard.StatsBanner', {
        extend: 'Ext.Container',
        alias:'widget.statsbanner',
        requires: [
            'Rally.Message',
            'Rally.apps.iterationtrackingboard.statsbanner.PlannedVelocity',
            'Rally.apps.iterationtrackingboard.statsbanner.TimeboxEnd',
            'Rally.apps.iterationtrackingboard.statsbanner.Defects',
            'Rally.apps.iterationtrackingboard.statsbanner.Accepted',
            'Rally.apps.iterationtrackingboard.statsbanner.Tasks',
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgress',
            'Rally.apps.iterationtrackingboard.statsbanner.CollapseExpand'
        ],
        mixins: [
            'Rally.Messageable',
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],
        cls: 'stats-banner',
        layout: 'hbox',
        border: 0,
        width: '100%',
        stateful: true,
        stateEvents: ['expand', 'collapse'],

        config: {
            context: null,
            expanded: false,
            optimizeLayouts: false
        },

        items: [
            {xtype: 'statsbannerplannedvelocity'},
            {xtype: 'statsbannertimeboxend'},
            {xtype: 'statsbanneraccepted'},
            {xtype: 'statsbannerdefects'},
            {xtype: 'statsbannertasks'},
            {xtype: 'statsbanneriterationprogress', flex: 2},
            {xtype: 'statsbannercollapseexpand', flex: 0}
        ],

        constructor: function(config) {
            if (config.optimizeLayouts) {
                config._isLayoutRoot = true;
            }
            this.callParent(arguments);
        },

        initComponent: function () {
            this.recordLoadBegin({
                description: 'initializing'
            });

            this.addEvents(
                /**
                 * @event
                 * Fires when expand is clicked
                 */
                'expand',
                /**
                 * @event
                 * Fires when collapse is clicked
                 */
                'collapse'
            );

            this._readyCount = 0;

            this.stateId = this.context.getScopedStateId('stats-banner');

            this.subscribe(this, Rally.Message.objectDestroy, this._update, this);
            this.subscribe(this, Rally.Message.objectCreate, this._update, this);
            this.subscribe(this, Rally.Message.objectUpdate, this._update, this);
            this.subscribe(this, Rally.Message.bulkUpdate, this._update, this);
            this.subscribe(this, Rally.Message.bulkImport, this._update, this);

            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],
                fetch: ['Defects:summary[State;ScheduleState+Blocked]', 'PlanEstimate', 'Requirement', 'FormattedID', 'Name', 'Blocked', 'BlockedReason',
                    'ScheduleState', 'State', 'Tasks:summary[State+Blocked]', 'TestCases'],
                useShallowFetch: true,
                sorters: [
                    {property: 'ScheduleState'}
                ],
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this
            });

            //need to configure the items at the instance level, not the class level (i.e. don't use the 'defaults' config)
            this.items = this._configureItems(this.items);

            this.on('expand', this._onExpand, this);
            this.on('collapse', this._onCollapse, this);
            this.callParent(arguments);

            this._update();
        },

        onRender: function () {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this._setExpandedOnChildItems();
            this.callParent(arguments);
        },

        applyState: function (state) {
            if (Ext.isDefined(state.expanded)) {
                this.setExpanded(state.expanded);
            }
            this._setExpandedOnChildItems();
        },

        getState: function () {
            return {
                expanded: this.expanded
            };
        },

        _setExpandedOnChildItems: function () {
            _.each(this.items.getRange(), function(item) {
                item.setExpanded(this.expanded);
            }, this);
        },

        _getItemDefaults: function () {
            return {
                flex: 1,
                context: this.context,
                store: this.store,
                expanded: this.expanded,
                parentComponent: this,
                listeners: {
                    ready: this._onReady,
                    scope: this
                }
            };
        },

        _onReady: function () {
            this._readyCount = this._readyCount + 1;
            if (this._readyCount === this.items.getCount()) {
                this.recordComponentReady();
                this._readyCount = 0;
                this._recordLoadEnd();
            }
        },

        _onCollapse: function () {
            this.addCls('collapsed');
            this.setExpanded(false);

            _.invoke(this.items.getRange(), 'collapse');
        },

        _onExpand: function () {
            this.removeCls('collapsed');
            this.setExpanded(true);

            _.invoke(this.items.getRange(), 'expand');
        },

        _hasTimebox: function () {
            return !!this.context.getTimeboxScope().getRecord();
        },

        _configureItems: function (items) {
            var defaults = this._getItemDefaults();

            return _.map(items, function(item) {
                return _.defaults(_.cloneDeep(item), defaults);
            });
        },

        _recordLoadEnd: function () {
            this.recordLoadEnd();
        },

        _update: function () {
            if(this._hasTimebox()) {
                this.store.load();
            } else {
                this._recordLoadEnd();
            }
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * @private
     * Allows displaying the stats banner settings
     *
     *
     *      @example
     *      Ext.create('Ext.Container', {
         *          items: [{
         *              xtype: 'rallystatsbannersettingsfield',
         *              value: {
         *                  showStatsBanner: true
         *              }
         *          }],
         *          renderTo: Ext.getBody().dom
         *      });
     *
     */
    Ext.define('Rally.apps.iterationtrackingboard.StatsBannerField', {
        extend: 'Ext.form.FieldContainer',
        requires: [
            'Rally.ui.CheckboxField'
        ],
        alias: 'widget.rallystatsbannersettingsfield',

        mixins: {
            field: 'Ext.form.field.Field'
        },

        layout: 'hbox',

        cls: 'stats-banner-settings',

        config: {
            /**
             * @cfg {Object}
             *
             * The column settings value for this field
             */
            value: undefined
        },

        initComponent: function() {
            this.callParent(arguments);

            this.mixins.field.initField.call(this);

            this.add([
                {
                    xtype: 'rallycheckboxfield',
                    name: 'showStatsBanner',
                    boxLabel: 'Show the Iteration Progress Banner',
                    submitValue: false,
                    margin: '0 0 0 80',
                    value: this.getValue().showStatsBanner
                }
            ]);
        },

        /**
         * When a form asks for the data this field represents,
         * give it the name of this field and the ref of the selected project (or an empty string).
         * Used when persisting the value of this field.
         * @return {Object}
         */
        getSubmitData: function() {
            var data = {};
            var showStatsBannerField = this.down('rallycheckboxfield');
            data[showStatsBannerField.name] = showStatsBannerField.getValue();
            return data;
        }
    });
})();



                (function () {
    var Ext = window.Ext4 || window.Ext;

    var defaultGridColumns = ['Name', 'ScheduleState', 'Blocked', 'PlanEstimate', 'Tasks', 'TaskEstimateTotal', 'TaskRemainingTotal', 'Owner', 'Defects', 'Discussion'];

    /**
     * Iteration Tracking Board App
     * The Iteration Tracking Board can be used to visualize and manage your User Stories and Defects within an Iteration.
     */
    Ext.define('Rally.apps.iterationtrackingboard.IterationTrackingBoardApp', {
        extend: 'Rally.app.TimeboxScopedApp',
        requires: [
            'Rally.data.Ranker',
            'Rally.data.wsapi.ModelFactory',
            'Rally.data.wsapi.TreeStoreBuilder',
            'Rally.ui.dialog.CsvImportDialog',
            'Rally.ui.gridboard.GridBoard',
            'Rally.apps.iterationtrackingboard.IterationTrackingTreeGrid',
            'Rally.ui.cardboard.plugin.FixedHeader',
            'Rally.ui.cardboard.plugin.Print',
            'Rally.ui.gridboard.plugin.GridBoardActionsMenu',
            'Rally.ui.gridboard.plugin.GridBoardAddNew',
            'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl',
            'Rally.ui.gridboard.plugin.GridBoardFieldPicker',
            'Rally.ui.cardboard.plugin.ColumnPolicy',
            'Rally.ui.gridboard.plugin.GridBoardToggleable',
            'Rally.ui.grid.plugin.TreeGridExpandedRowPersistence',
            'Rally.ui.grid.plugin.TreeGridChildPager',
            'Rally.ui.gridboard.plugin.GridBoardCustomView',
            'Rally.ui.filter.view.ModelFilter',
            'Rally.ui.filter.view.OwnerFilter',
            'Rally.ui.filter.view.OwnerPillFilter',
            'Rally.ui.filter.view.TagPillFilter',
            'Rally.app.Message',
            'Rally.apps.iterationtrackingboard.StatsBanner',
            'Rally.apps.iterationtrackingboard.StatsBannerField',
            'Rally.clientmetrics.ClientMetricsRecordable',
            'Rally.apps.common.RowSettingsField'
        ],

        mixins: [
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],
        componentCls: 'iterationtrackingboard',
        alias: 'widget.rallyiterationtrackingboard',

        settingsScope: 'project',
        userScopedSettings: true,
        scopeType: 'iteration',
        autoScroll: false,

        config: {
            defaultSettings: {
                showCardAge: true,
                showStatsBanner: true,
                cardAgeThreshold: 3
            },
            includeStatsBanner: true
        },
		
		items: [{
            xtype: 'container',
            cls: 'header'
        },
		/*
		{
			xtype: 'container',
            items:[{
				xtype: 'container',
                itemId: 'featureComboBoxContainer'
			}]
		}
		*/
		
		{
			xtype: 'container',
            itemId: 'featureComboBox'
		}
		],
		
		launch: function() {
			
			this.features = null;
			this.requiremnts = null; 
			app=this;
            var context = this.getContext();
			
            if (this._hasScope()) {
                this.onScopedDashboard = true;
                this.onTimeboxScopeChange(context.getTimeboxScope());
            } else {
                this.onScopedDashboard = false;
                this._addScopeComboBox();
				this._addFeatureComboBox();
            }
        },	
		
        modelNames: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],

        constructor: function(config) {
            _.defaults(config, { layout: 'anchor'});

            this.callParent(arguments);
        },
		
		_addFeatureComboBox:function(){
			this.featureComboBox  = Ext.create('Rally.ui.combobox.ComboBox', {
			//itemId:'featureComboBox',
            fieldLabel: 'Choose a Feature:',
            multiselect: false, // not sure if this should be set to true or false (ask about practices)
            shouldRespondToScopeChange: true,
            editable: false,
            allowNoEntry: true,
            noEntryValue: null,
            autoWidth: true,
            grow: true,
            growToLongestValue: true,
            storeConfig: {
                model: 'PortfolioItem/Feature',
                fetch: ['FormattedID', 'Name'],
                context: {
                    project: '/project/28077133199',//pointing to Hudson
                    projectScopeDown: true
                },
                autoLoad: true,
                remoteSort: false,
                remoteFilter: true
            },
            stateId: 'featureSelection',
            stateful: true,
            lastQuery: '',
            listConfig: {
                itemTpl: '{FormattedID}:  {Name}'
            },
            listeners: {
                select: function(combo, records, eOpts) {
                    this.features = records;
					console.log('this.features1',this.features);
                    this.onScopeChange();
					console.log('calling onFeatureScopeChange');
                }.bind(this),
                ready: function(combo, eOpts) {
                    this.features = combo.lastSelection;
					this.onScopeChange();
                    //this.addRequiremntComboBox();
                }.bind(this)
            }
        });
        this.down('#featureComboBox').add(this.featureComboBox);
		},
		
    onFeatureScopeChange: function () {
        //this.requiremntComboBox.doQuery(this._requiremntBoxFilterByFeature().toString(), false, false);
        //this.requiremntComboBox.collapse();

        this.requiremnts = null;

        //this.down('#gridBoard').filter(this._getGridboardFilters(), true, true);
    },

    onRequiremntScopeChange: function () {
        //this.getComponent('gridBoard').filter(this._getGridboardFilters(), true, true);
    },

    /************************************************************************************
    ********* Filter the requiremnt combobox based on the feature chosen by user ********
    ************************************************************************************/
    _requiremntBoxFilterByFeature: function () {
        if (this.features !== null || this.features !== undefined) {
            var feature = this.features[0],
                filter = null;
            if (feature.data.ObjectID === null || feature.data.ObjectID === undefined) {
                filter = '(Parent.Parent.FormattedID = "PR11")';
            } else {
                filter = '(Parent.ObjectID = "' + feature.data.ObjectID + '")';
            }
            return Rally.data.wsapi.Filter.fromQueryString(filter);
        }
    },

    /************************************************************************************
    ************** Used to add user's feature choice to filter for the grid *************
    ************************************************************************************/
    _filterByFeature: function() {
		console.log('this.features2',this.features);
		console.log('#featureComboBox = '+this.down('#featureComboBox').getComponent('#featureComboBox'));
		//this.features=this.down('#featureComboBox').getComponent('#featureComboBox');
        if (this.features !== null || this.features !== undefined) {
            return _.compact(_.map(Ext.Array.from(this.features), function(feature) {
                var filter = null;
                if (feature.data.ObjectID === null || feature.data.ObjectID === undefined) {
                    filter = '(Requiremnt.Parent.Parent.FormattedID = "PR11")';
                } else {
                    filter = '(Requiremnt.Parent.ObjectID = "' + feature.data.ObjectID + '")';
                }
                return Rally.data.wsapi.Filter.fromQueryString(filter);
            }));
        }
    },

    /************************************************************************************
    ************* Used to add user's requiremnt choice to filter for the grid ***********
    ************************************************************************************/
		_filterByRequiremnt: function() {
			if (this.requiremnts != null && this.requiremnts.length > 0) {
				var requiremnt = this.requiremnts[0];
				if (requiremnt.data.ObjectID != null) {
					filter = '(Requiremnt.ObjectID = "' + requiremnt.data.ObjectID.toString() + '")';
					return Rally.data.wsapi.Filter.fromQueryString(filter);
				}
			}
			return null;
		},

        onScopeChange: function() {
            if(!this.rendered) {
                this.on('afterrender', this.onScopeChange, this, {single: true});
                return;
            }

            var me = this;

            this.suspendLayouts();

            var grid = this.down('rallytreegrid');
            if (grid) {
                // reset page count to 1.
                // must be called here to reset persisted page count value.
                grid.fireEvent('storecurrentpagereset');
            }

            if (this._shouldShowStatsBanner()){
                this._addStatsBanner();
            }

            this._buildGridStore().then({
                success: function(gridStore) {
                    var model = gridStore.model;
                    if(_.isFunction(model.getArtifactComponentModels)) {
                        this.modelNames = _.intersection(_.pluck(gridStore.model.getArtifactComponentModels(),'displayName'),this.modelNames);
                    } else {
                        this.modelNames = [model.displayName];
                    }
                    this._addGridBoard(gridStore);
                },
                scope: this
            }).always(function() {
                me.resumeLayouts(true);
            });
        },

        getSettingsFields: function () {
            var fields = this.callParent(arguments);

            fields.push({
                type: 'cardage',
                config: {
                    margin: '0 0 0 80',
                    width: 300
                }
            });

            fields.push({
                name: 'groupHorizontallyByField',
                xtype: 'rowsettingsfield',
                fieldLabel: 'Swimlanes',
                margin: '10 0 0 0',
                mapsToMultiplePreferenceKeys: ['showRows', 'rowsField'],
                readyEvent: 'ready',
                isAllowedFieldFn: function() { return false; },
                explicitFields: [
                    {name: 'Blocked', value: 'Blocked'},
                    {name: 'Owner', value: 'Owner'},
                    {name: 'Sizing', value: 'PlanEstimate'},
                    {name: 'Expedite', value: 'Expedite'}
                ]
            });

            return fields;
        },

        getUserSettingsFields: function () {
            var fields = this.callParent(arguments);

            fields.push({
                xtype: 'rallystatsbannersettingsfield',
                fieldLabel: '',
                mapsToMultiplePreferenceKeys: ['showStatsBanner']
            });

            return fields;
        },

        _buildGridStore: function() {
            var context = this.getContext(),
                config = {
                    context: context.getDataContext(),
                    models: this.modelNames,
                    autoLoad: false,
                    remoteSort: true,
                    root: {expanded: true},
                    enableHierarchy: true,
                    pageSize: this.getGridPageSizes()[1],
                    childPageSizeEnabled: true,
                    fetch: ['PlanEstimate', 'Release', 'Iteration']
                };

            return Ext.create('Rally.data.wsapi.TreeStoreBuilder').build(config);
        },

        _shouldShowStatsBanner: function() {
            return this.includeStatsBanner && this.getSetting('showStatsBanner');
        },

        _addStatsBanner: function() {
           this.remove('statsBanner');
           this.add({
                xtype: 'statsbanner',
                itemId: 'statsBanner',
                context: this.getContext(),
                margin: '0 0 5px 0',
                shouldOptimizeLayouts: this.config.optimizeFrontEndPerformanceIterationStatus,
                listeners: {
                    resize: this._resizeGridBoardToFillSpace,
                    scope: this
                }
           });
        },

        _addGridBoard: function (gridStore) {
            var context = this.getContext();

            this.remove('gridBoard');

            this.gridboard = this.add({
                itemId: 'gridBoard',
                xtype: 'rallygridboard',
                stateId: 'iterationtracking-gridboard',
                context: context,
                plugins: this._getGridBoardPlugins(),
                modelNames: this.modelNames,
                cardBoardConfig: this._getBoardConfig(),
                gridConfig: this._getGridConfig(gridStore),
                layout: 'anchor',
                storeConfig: {
                    useShallowFetch: false,
                    filters: this._getGridboardFilters(gridStore.model)
                },
                listeners: {
                    load: this._onLoad,
                    toggle: this._onToggle,
                    recordupdate: this._publishContentUpdatedNoDashboardLayout,
                    recordcreate: this._publishContentUpdatedNoDashboardLayout,
                    scope: this
                },
                height: Math.max(this._getAvailableGridBoardHeight(), 150)
            });
        },

        _getGridboardFilters: function(model) {
			
			var self = this;
            var timeboxScope = this.getContext().getTimeboxScope(),
                timeboxFilter = timeboxScope.getQueryFilter(),
				featureFilter = this._filterByFeature(),
                //filters = [];
				
				//Solving for Unscheduled Issue -------------------------------------------
				filters = [timeboxFilter];
				
				console.log('featureFilter',featureFilter);
				//console.log('_filterByFeature()',this._filterByFeature());
				console.log('this.getContext().getSubscription().StoryHierarchyEnabled = ',this.getContext().getSubscription().StoryHierarchyEnabled);

				
            if (!timeboxScope.getRecord() && this.getContext().getSubscription().StoryHierarchyEnabled) {
				
				console.log('this.getContext().getSubscription().StoryHierarchyEnabled 2 = ',this.getContext().getSubscription().StoryHierarchyEnabled);
				console.log('timeboxScope.getRecord() = ',timeboxScope.getRecord());
				console.log('-----------------------');
				//console.log('this._createLeafStoriesOnlyFilter(model)',self._createLeafStoriesOnlyFilter(model));
                /*
				timeboxFilter.push(this._createLeafStoriesOnlyFilter(model));
                timeboxFilter.push(this._createUnassociatedDefectsOnlyFilter(model));
				*/
				
				filters.push(this._createLeafStoriesOnlyFilter(model));
                filters.push(this._createUnassociatedDefectsOnlyFilter(model));
            }
			
			if (timeboxFilter != null) {
				filters = filters.concat(timeboxFilter);
			}
		
			if (featureFilter != null) {
				filters = filters.concat(featureFilter);
			}
            
			var finalFilter = filters[0];

        /************************************************************************************
        ******* add all the filters together using AND, no filters are OR'd in this app *****
        ************************************************************************************/
			for (i=1;i<filters.length;i++) {
				if (filters[i] !== null) {
					finalFilter = finalFilter.and(filters[i]);
				}
			}

			return finalFilter;
        },

        _createLeafStoriesOnlyFilter: function(model) {
            var typeDefOid = model.getArtifactComponentModel('HierarchicalRequirement').typeDefOid;
			console.log(typeDefOid);

			console.log('1');
            var userStoryFilter = Ext.create('Rally.data.wsapi.Filter', {
                property: 'TypeDefOid',
                value: typeDefOid
            });

			console.log('2',userStoryFilter);
            var noChildrenFilter = Ext.create('Rally.data.wsapi.Filter', {
                property: 'DirectChildrenCount',
                value: 0
            });

			console.log('3',noChildrenFilter);
            var notUserStoryFilter = Ext.create('Rally.data.wsapi.Filter', {
                property: 'TypeDefOid',
                value: typeDefOid,
                operator: '!='
            });

			console.log('4',notUserStoryFilter);
            return userStoryFilter.and(noChildrenFilter).or(notUserStoryFilter);
        },

        _createUnassociatedDefectsOnlyFilter: function(model) {
            var typeDefOid = model.getArtifactComponentModel('Defect').typeDefOid,
                isADefect = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'TypeDefOid',
                    value: typeDefOid
                }),
                parentRequirementIsScheduled = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Requirement.Iteration',
                    operator: '!=',
                    value: null
                }),
                hasNoParentRequirement = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Requirement',
                    operator: '=',
                    value: null
                }),
                isNotADefect = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'TypeDefOid',
                    value: typeDefOid,
                    operator: '!='
                });

            return isADefect.and(parentRequirementIsScheduled.or(hasNoParentRequirement)).or(isNotADefect);
        },

        _getBoardConfig: function() {
            var config = {
                plugins: [
                    {ptype: 'rallycardboardprinting', pluginId: 'print'},
                    {ptype: 'rallyfixedheadercardboard'}
                ],
                columnConfig: {
                    additionalFetchFields: ['PortfolioItem'],
                    plugins: [{
                        ptype: 'rallycolumnpolicy',
                        app: this
                    }],
                    requiresModelSpecificFilters: false
                },
                cardConfig: {
                    showAge: this.getSetting('showCardAge') ? this.getSetting('cardAgeThreshold') : -1
                },
                listeners: {
                    filter: this._onBoardFilter,
                    filtercomplete: this._onBoardFilterComplete
                }
            };

            if (this.getSetting('showRows') && this.getSetting('rowsField')) {
                Ext.merge(config, {
                    rowConfig: {
                        field: this.getSetting('rowsField'),
                        sortDirection: 'ASC'
                    }
                });
            }

            return config;
        },

        _getAvailableGridBoardHeight: function() {
            var height = this.getHeight();
            if (this._shouldShowStatsBanner() && this.down('#statsBanner').rendered) {
                height -= this.down('#statsBanner').getHeight();
            }
            if (this.getHeader()) {
                height -= this.getHeader().getHeight();
            }
            return height;
        },

        _getGridBoardPlugins: function() {
            var plugins = [{
                ptype: 'rallygridboardaddnew'
            }];
            var context = this.getContext();

            plugins.push({
                ptype: 'rallygridboardcustomfiltercontrol',
                filterChildren: true,
                filterControlConfig: {
                    blackListFields: ['Iteration', 'PortfolioItem'],
                    whiteListFields: ['Milestones'],
                    modelNames: this.modelNames,
                    stateful: true,
                    stateId: context.getScopedStateId('iteration-tracking-custom-filter-button')
                },
                showOwnerFilter: true,
                ownerFilterControlConfig: {
                    stateful: true,
                    stateId: context.getScopedStateId('iteration-tracking-owner-filter')
                }
            });

            plugins.push('rallygridboardtoggleable');

            var actionsMenuItems = [
            {
                text: 'Import User Stories...',
                handler: this._importHandler({
                    type: 'HierarchicalRequirement',
                    title: 'Import User Stories'
                })
            }, {
                text: 'Import Tasks...',
                handler: this._importHandler({
                    type: 'Task',
                    title: 'Import Tasks'
                })
            }, {
                text: 'Export...',
                handler: this._exportHandler,
                scope: this
            }];

            actionsMenuItems.push({
                text: 'Print...',
                handler: this._printHandler,
                scope: this
            });

            plugins.push({
                ptype: 'rallygridboardactionsmenu',
                itemId: 'printExportMenuButton',
                menuItems: actionsMenuItems,
                buttonConfig: {
                    iconCls: 'icon-export',
                    toolTipConfig: {
                        html: 'Import/Export/Print',
                        anchor: 'top',
                        hideDelay: 0
                    }
                }
            });

            plugins.push({
                ptype: 'rallygridboardfieldpicker',
                headerPosition: 'left',
                gridFieldBlackList: [
                    'Estimate',
                    'ToDo'
                ],
                boardFieldBlackList: [
                    'Successors',
                    'Predecessors'
                ],
                modelNames: this.modelNames,
                boardFieldDefaults: (this.getSetting('cardFields') && this.getSetting('cardFields').split(',')) ||
                    ['Parent', 'Tasks', 'Defects', 'Discussion', 'PlanEstimate', 'Iteration']
            });

            if (context.isFeatureEnabled('ITERATION_TRACKING_CUSTOM_VIEWS')) {
                plugins.push(this._getCustomViewConfig());
            }

            return plugins;
        },

        setSize: function() {
            this.callParent(arguments);
            this._resizeGridBoardToFillSpace();
        },

        _importHandler: function(options) {
            return _.bind(function() {
                Ext.widget({
                    xtype: 'rallycsvimportdialog',
                    type: options.type,
                    title: options.title,
                    params: {
                        iterationOid: this._getIterationOid()
                    }
                });
            }, this);
        },

        _exportHandler: function() {
            var context = this.getContext();
            var params = {
                cpoid: context.getProject().ObjectID,
                projectScopeUp: context.getProjectScopeUp(),
                projectScopeDown: context.getProjectScopeDown(),
                iterationKey: this._getIterationOid()
            };

            window.location = Ext.String.format('{0}/sc/exportCsv.sp?{1}',
                Rally.environment.getServer().getContextUrl(),
                Ext.Object.toQueryString(params)
            );
        },

        _printHandler: function() {
            var timeboxScope = this.getContext().getTimeboxScope();

            Ext.create('Rally.ui.grid.TreeGridPrintDialog', {
                grid: this.gridboard.getGridOrBoard(),
                treeGridPrinterConfig: {
                    largeHeaderText: 'Iteration Summary',
                    smallHeaderText: timeboxScope.getRecord() ? timeboxScope.getRecord().get('Name') : 'Unscheduled'
                }
            });
        },

        _getIterationOid: function() {
            var iterationId = '-1';
            var timebox = this.getContext().getTimeboxScope();

            if (timebox && timebox.getRecord()) {
                iterationId = timebox.getRecord().getId();
            }
            return iterationId;
        },

        _resizeGridBoardToFillSpace: function() {
            if (this.gridboard) {
                this.gridboard.setHeight(this._getAvailableGridBoardHeight());
            }
        },

        _getCustomViewConfig: function() {
            var customViewConfig = {
                ptype: 'rallygridboardcustomview',
                stateId: 'iteration-tracking-board-app',

                defaultGridViews: [{
                    model: ['UserStory', 'Defect', 'DefectSuite', 'TestSet'],
                    name: 'Defect Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'Discussion',
                                'Priority',
                                'Severity',
                                'FoundIn',
                                'FixedIn',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                defectstatusview: {
                                    isActiveFilter: false,
                                    itemId: 'defectstatusview',
                                    queryString: '((Defects.ObjectID != null) OR (Priority != null))'
                                }
                            }
                        }
                    }
                }, {
                    model: ['UserStory', 'Defect', 'TestSet', 'DefectSuite'],
                    name: 'Task Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'PlanEstimate',
                                'TaskEstimate',
                                'ToDo',
                                'Discussions',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                taskstatusview: {
                                    isActiveFilter: false,
                                    itemId: 'taskstatusview',
                                    queryString: '(Tasks.ObjectID != null)'
                                }
                            }
                        }
                    }
                }, {
                    model: ['UserStory', 'Defect', 'TestSet'],
                    name: 'Test Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'Discussions',
                                'LastVerdict',
                                'LastBuild',
                                'LastRun',
                                'ActiveDefects',
                                'Priority',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                teststatusview: {
                                    isActiveFilter: false,
                                    itemId: 'teststatusview',
                                    queryString: '(TestCases.ObjectID != null)'
                                }
                            }
                        }
                    }
                }]
            };

            customViewConfig.defaultBoardViews = _.cloneDeep(customViewConfig.defaultGridViews);
            _.each(customViewConfig.defaultBoardViews, function(view) {
                delete view.state.cmpState;
            });

            return customViewConfig;
        },

        _getGridConfig: function (gridStore) {
            var context = this.getContext(),
                stateString = 'iteration-tracking-treegrid',
                stateId = context.getScopedStateId(stateString),
                useFixedHeightRows = Ext.isIE && context.isFeatureEnabled('S78815_ITERATON_TREE_GRID_APP_FIXED_ROW_HEIGHT');

            var gridConfig = {
                xtype: 'rallyiterationtrackingtreegrid',
                store: gridStore,
                columnCfgs: this._getGridColumns(),
                summaryColumns: this._getSummaryColumnConfig(),
                enableInlineAdd: true,
                expandAllInColumnHeaderEnabled: true,
                inlineAddConfig: {
                    enableAddPlusNewChildStories: false
                },
                enableBulkEdit: true,
                pagingToolbarCfg: {
                    pageSizes: this.getGridPageSizes(),
                    comboboxConfig: {
                        defaultSelectionPosition: 'last'
                    }
                },
                plugins: [],
                stateId: stateId,
                stateful: true,
                variableRowHeight: !useFixedHeightRows,
                bufferedRenderer: true
            };

            gridConfig.plugins.push({
                ptype: 'rallytreegridexpandedrowpersistence'
            });

            return gridConfig;
        },

        _getSummaryColumnConfig: function () {
            var taskUnitName = this.getContext().getWorkspace().WorkspaceConfiguration.TaskUnitName,
                planEstimateUnitName = this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName;

            return [
                {
                    field: 'PlanEstimate',
                    type: 'sum',
                    units: planEstimateUnitName
                },
                {
                    field: 'TaskEstimateTotal',
                    type: 'sum',
                    units: taskUnitName
                },
                {
                    field: 'TaskRemainingTotal',
                    type: 'sum',
                    units: taskUnitName
                },
                {
                    field: 'TaskActualTotal',
                    type: 'sum',
                    units: taskUnitName
                }
            ];
        },

        _getGridColumns: function (columns) {
            return columns ? _.without(columns, 'FormattedID') : defaultGridColumns;
        },

        _onLoad: function () {
            this._publishContentUpdated();

            var additionalMetricData = {};

            if  (this.gridboard.getToggleState() === 'board') {
                additionalMetricData = {
                    miscData: {
                        swimLanes: this.getSetting('showRows'),
                        swimLaneField: this.getSetting('rowsField')
                    }
                };
            }

            this.recordComponentReady(additionalMetricData);

            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _onBoardFilter: function () {
            this.setLoading(true);
        },

        _onBoardFilterComplete: function () {
            this.setLoading(false);
        },

        _hidePrintButton: function(hide, gridboard) {
            var button, menuItem;

            if (gridboard) {
                button = _.find(gridboard.plugins, {itemId: 'printExportMenuButton'});

                if (button) {
                    menuItem = _.find(button.menuItems, {text: 'Print...'});

                    if (menuItem) {
                        menuItem.hidden = hide;
                    }
                }
            }
        },

        _onToggle: function (toggleState, gridOrBoard, gridboard) {
            var appEl = this.getEl();

            if (toggleState === 'board') {
                appEl.replaceCls('grid-toggled', 'board-toggled');
                this._hidePrintButton(true, gridboard);
            } else {
                appEl.replaceCls('board-toggled', 'grid-toggled');
                this._hidePrintButton(false, gridboard);
            }
            this._publishContentUpdated();
        },

        _publishContentUpdated: function () {
            this.fireEvent('contentupdated');
        },

        _publishContentUpdatedNoDashboardLayout: function () {
            this.fireEvent('contentupdated', {dashboardLayout: false});
        },

        getGridPageSizes: function() {
            return [10, 25, 50];
        }
    });
})();

            Rally.launchApp('Rally.apps.iterationtrackingboard.IterationTrackingBoardApp', {
                name:"Iteration Tracking Board",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .stat-panel .collapsed-widget,
.stat-panel .collapsed-widget > div {
  display: none;
}
.stat-panel .expanded-widget,
.stat-panel .expanded-widget > div {
  display: block;
}
.stat-panel.collapsed .collapsed-widget,
.stat-panel.collapsed .collapsed-widget > div {
  display: inline-block;
}
.stat-panel.collapsed .expanded-widget,
.stat-panel.collapsed .expanded-widget > div {
  display: none;
}
.stats-banner .stat-panel {
  border-left: 1px solid #d6d6d6;
  height: 110px;
  text-align: center;
}
.stats-banner .stat-panel:first-child {
  border-left: 0;
}
.stats-banner .stat-panel:last-child {
  border-left-width: 2px;
}
.stats-banner .stat-panel .stat-title {
  color: #222222;
  font-family: ProximaNovaSemiBold, Helvetica, Arial;
  font-size: 14px;
  padding-top: 5px;
}
.stats-banner .stat-panel .stat-metric {
  color: #666666;
  font-family: ProximaNovaLight, Helvetica, Arial;
  font-size: 18px;
  height: 85px;
  padding-top: 20px;
}
.stats-banner .stat-panel .stat-metric .metric-percent {
  display: inline;
  font-size: 12px;
  vertical-align: super;
}
.stats-banner .stat-panel .stat-metric .metric-icon {
  color: #888888;
  font-size: 18px;
  padding-right: 5px;
}
.stats-banner .stat-panel .stat-metric .metric-chart {
  position: absolute;
  top: 22px;
  width: 100%;
}
.stats-banner .stat-panel .stat-metric .metric-subtext {
  bottom: 7px;
  color: #888888;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 11px;
  position: absolute;
  text-transform: lowercase;
  width: 100%;
}
.stats-banner .stat-panel .stat-metric .metric-chart-text {
  position: absolute;
  top: 43px;
  width: 100%;
}
.stats-banner .stat-panel .stat-metric .metric-chart-text.percent-offset {
  left: 3px;
  top: 41px;
}
.stats-banner .stat-panel .stat-metric .stat-secondary {
  color: #888888;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 11px;
  text-transform: lowercase;
}
.stats-banner .stat-panel .stat-metric .stat-carousel {
  display: inline-block;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 12px;
  margin-top: -20px;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .rally-carousel-pane .x-box-inner {
  top: 0px !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .rly-carousel > span {
  display: inline !important;
  width: auto !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .rly-carousel > span > div {
  display: block !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .rly-carousel .carousel-panel > span {
  display: inline !important;
  width: auto !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .rly-carousel .carousel-panel > span > div {
  display: block !important;
}
.stats-banner .stat-panel .chart .highcharts-container {
  cursor: pointer;
}
.stats-banner .stat-panel .gauge .chart .highcharts-container {
  cursor: default;
}
.stats-banner .stat-panel .header {
  display: none;
}
.stats-banner .stat-panel.collapse-expand {
  background-color: #f6f6f6;
  width: 23px;
}
.stats-banner .stat-panel.collapse-expand .toggle-icon {
  color: #c0c0c0;
  font-size: 15px;
  padding-top: 4px;
  position: relative;
  right: 1px;
}
.stats-banner .stat-panel.collapse-expand:hover {
  cursor: pointer;
}
.stats-banner .stat-panel.collapse-expand:hover .toggle-icon {
  color: #444444;
}
.stats-banner.collapsed {
  cursor: pointer;
}
.stats-banner.collapsed .stat-panel {
  height: 25px;
  padding-top: 2px;
}
.stats-banner.collapsed .stat-panel.collapse-expand .toggle-icon {
  padding-top: 2px;
}
.stats-banner.collapsed .stat-panel .metric-icon {
  color: #888888;
  font-size: 14px;
  padding-right: 5px;
  vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-title {
  color: #222222;
  display: inline;
  font-family: ProximaNovaSemiBold, Helvetica, Arial;
  font-size: 12px;
  vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-metric {
  color: #888888;
  display: inline;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 14px;
  height: auto;
  padding-top: auto;
  padding-left: 10px;
  vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-metric .stat-metric-secondary {
  font-size: 11px;
}
.stats-banner.collapsed .stat-panel .stat-metric .metric-percent {
  font-size: 10px;
  vertical-align: super;
}
.pie-chart-legend {
  color: #3E576F;
  font-size: 12px;
  padding: 5px;
  border: 1px solid #909090;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}
.pie-chart-legend .legend-swatch {
  width: 17px;
  height: 12px;
  border: 1px solid #EEE;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
  float: left;
  margin: 0 3px 0 6px;
}
.pie-chart-legend .legend-swatch.defined-sample-swatch {
  background: #E0E0E0;
  /* light-gray */
}
.pie-chart-legend .legend-swatch.in-progress-sample-swatch {
  background: #00a9e0;
}
.pie-chart-legend .legend-swatch.completed-sample-swatch {
  background: #8dc63f;
}
.pie-chart-legend .legend-swatch.blocked-sample-swatch {
  background: #EF3F35;
  /* rally red */
}
.iteration-progress-dialog .rly-carousel .carousel-panel .scroll-button span {
  width: 45px;
  height: 50px;
  line-height: 46px;
}
.iteration-progress-dialog .rly-carousel .carousel-panel .scroll-button span:hover {
  background-color: #e6e6e6;
  color: #666666;
}
.iteration-progress-toggle-button-group {
  margin-bottom: 5px;
}
.x-gecko .stats-banner.collapsed .stat-panel .stat-metric {
  line-height: 20px;
  vertical-align: top;
}
.x-gecko .stats-banner.collapsed .stat-panel .stat-metric .metric-percent {
  line-height: 10px;
}
.x-gecko.x-mac .stats-banner.collapsed .stat-panel .stat-metric {
  line-height: 22px;
}

    </style>

    <style type="text/css">
        .iterationtrackingboard {
  overflow: hidden;
}
.iterationtrackingboard .header {
  line-height: normal;
  padding: 5px 5px 2px 5px;
}
.iterationtrackingboard .header .add-new {
  float: left;
}
.iterationtrackingboard .header .add-new .new {
  margin-left: 0;
}
.iterationtrackingboard .header .rui-triggerfield {
  margin-bottom: 5px;
}
.iterationtrackingboard .blank-slate-msg .x-panel-body {
  clear: both;
  padding-top: 20px;
  text-align: center;
}
.iterationtrackingboard .gridboard-filter-control {
  height: 22px;
  margin: 3px 0px 0px 5px;
}
.settings-no-grid {
  padding: 10px;
}

    </style>
</head>
<body>
</body>
</html>
